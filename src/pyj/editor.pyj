# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2018, Kovid Goyal <kovid at kovidgoyal.net>
# globals: CSSRule
from __python__ import bound_methods, hash_literals

def is_hidden(elem):
    while elem:
        if (elem.style and (elem.style.visibility is 'hidden' or elem.style.display is 'none')):
            return True
        elem = elem.parentNode
    return False


def is_block(elem):
    style = window.getComputedStyle(elem)
    return style.display is 'block' or style.display is 'flex-box' or style.display is 'box'


def in_table(elem):
    while elem:
        if elem.tagName?.toLowerCase() is 'table':
            return True
        elem = elem.parentNode
    return False


def find_containing_block(elem):
    while elem and elem.getAttribute('data-is-block') != '1':
        elem = elem.parentNode
    return elem


INHERITED_PROPS = {  # {{{
		'azimuth':						'2',
		'border-collapse':				'2',
		'border-spacing':				'2',
		'caption-side':					'2',
		'color':						'2',
		'cursor':						'2',
		'direction':					'2',
		'elevation':					'2',
		'empty-cells':					'2',
		'fit':							'3',
		'fit-position':					'3',
		'font':							'2',
		'font-family':					'2',
		'font-size':					'2',
		'font-size-adjust':				'2',
		'font-stretch':					'2',
		'font-style':					'2',
		'font-variant':					'2',
		'font-weight':					'2',
		'hanging-punctuation':			'3',
		'hyphenate-after':				'3',
		'hyphenate-before':				'3',
		'hyphenate-character':			'3',
		'hyphenate-lines':				'3',
		'hyphenate-resource':			'3',
		'hyphens':						'3',
		'image-resolution':				'3',
		'letter-spacing':				'2',
		'line-height':					'2',
		'line-stacking':				'3',
		'line-stacking-ruby':			'3',
		'line-stacking-shift':			'3',
		'line-stacking-strategy':		'3',
		'list-style':					'2',
		'list-style-image':				'2',
		'list-style-position':			'2',
		'list-style-type':				'2',
		'marquee-direction':			'3',
		'orphans':						'2',
		'overflow-style':				'3',
		'page':							'2',
		'page-break-inside':			'2',
		'pitch':						'2',
		'pitch-range':					'2',
		'presentation-level':			'3',
		'punctuation-trim':				'3',
		'quotes':						'2',
		'richness':						'2',
		'ruby-align':					'3',
		'ruby-overhang':				'3',
		'ruby-position':				'3',
		'speak':						'2',
		'speak-header':					'2',
		'speak-numeral':				'2',
		'speak-punctuation':			'2',
		'speech-rate':					'2',
		'stress':						'2',
		'text-align':					'2',
		'text-align-last':				'3',
		'text-emphasis':				'3',
		'text-height':					'3',
		'text-indent':					'2',
		'text-justify':					'3',
		'text-outline':					'3',
		'text-replace':					'?',
		'text-shadow':					'3',
		'text-transform':				'2',
		'text-wrap':					'3',
		'visibility':					'2',
		'voice-balance':				'3',
		'voice-family':					'2',
		'voice-rate':					'3',
		'voice-pitch':					'3',
		'voice-pitch-range':			'3',
		'voice-stress':					'3',
		'voice-volume':					'3',
		'volume':						'2',
		'white-space':					'2',
		'white-space-collapse':			'3',
		'widows':						'2',
		'word-break':					'3',
		'word-spacing':					'2',
		'word-wrap':					'3',

        # the mozilla extensions are all proprietary properties
		'-moz-force-broken-image-icon':	'm',
		'-moz-image-region':			'm',
		'-moz-stack-sizing':			'm',
		'-moz-user-input':				'm',
		'-x-system-font':				'm',

        # the opera extensions are all draft implementations of CSS3 properties
		'-xv-voice-balance':			'o',
		'-xv-voice-pitch':				'o',
		'-xv-voice-pitch-range':		'o',
		'-xv-voice-rate':				'o',
		'-xv-voice-stress':				'o',
		'-xv-voice-volume':				'o',

        # the explorer extensions are all draft implementations of CSS3 properties
		'-ms-text-align-last':			'e',
		'-ms-text-justify':				'e',
		'-ms-word-break':				'e',
		'-ms-word-wrap':				'e'
}  # }}}


def get_sourceline_address(node):
    sourceline = parseInt(node.getAttribute('data-lnum'))
    tags = v'[]'
    for elem in document.querySelectorAll(f'[data-lnum="{sourceline}"]'):
        tags.push(elem.tagName.toLowerCase())
        if elem is node:
            break
    return v'[sourceline, tags]'


def get_color(property, val):
    color = None
    if property.indexOf('color') > -1:
        try:
            color = window.parseCSSColor(val)  # Use the csscolor library to get an rgba 4-tuple
        except:
            color = None
    return color


def get_style_properties(style, all_properties, node_style, is_ancestor):
    i = 0
    properties = v'[]'
    while i < style.length:
        property = style.item(i)?.toLowerCase()
        val = style.getPropertyValue(property)
        if property and val and (not is_ancestor or INHERITED_PROPS[property]):
            properties.push(v'[property, val, style.getPropertyPriority(property), get_color(property, val)]')
            if not all_properties.hasOwnProperty(property):
                all_properties[property] = v'[node_style.getPropertyValue(property), get_color(property, cval)]'
        i += 1
    return properties


def process_rules(node, cssRules, address, sheet, sheet_index, matching_selectors, all_properties, node_style, is_ancestor, ans):
    for rule_index in range(cssRules.length):
        rule = cssRules[rule_index]
        rule_address = address.concat([rule_index])
        if rule.type is CSSRule.MEDIA_RULE:
            process_rules(node, rule.cssRules, rule_address, sheet, sheet_index, matching_selectors, all_properties, node_style, is_ancestor, ans)
            continue
        if rule.type is not CSSRule.STYLE_RULE:
            continue
        # As a performance improvement, instead of running the match on every
        # rule, we simply check if its selector is one of the matching
        # selectors returned by getMatchedCSSRules. However,
        # getMatchedCSSRules ignores rules in media queries that dont apply, so we check them manually
        st = rule.selectorText
        if st and (matching_selectors.hasOwnProperty(st) or (rule_address.length > 1 and node.matches(st))):
            type = 'sheet'
            href = sheet.href
            if href is None:
                href = get_sourceline_address(sheet.ownerNode)
                type = 'elem'
            parts = st.split(',')  # We only want the first matching selector
            if parts.length > 1:
                for q in parts:
                    if node.matches(q):
                        st = q
                        break
            properties = get_style_properties(rule.style, all_properties, node_style, is_ancestor)
            if properties.length > 0:
                data = {'selector':st, 'type':type, 'href':href, 'properties':properties, 'rule_address':rule_address, 'sheet_index':sheet_index}
                ans.push(data)

def get_matched_css(node, is_ancestor, all_properties):
    # WebKit sets parentStyleSheet == null for rules returned by getMatchedCSSRules so we cannot use them directly
    rules = node.ownerDocument.defaultView.getMatchedCSSRules(node, '')
    if not rules:
        rules = v'[]'
    matching_selectors = {}
    for rule in rules:
        matching_selectors[rule.selectorText] = True
    ans = v'[]'
    node_style = window.getComputedStyle(node)

    sheets = document.styleSheets
    for sheet_index in range(sheets.length):
        sheet = sheets[sheet_index]
        if sheet.disabled or not sheet.cssRules:
            continue
        process_rules(node, sheet.cssRules, [], sheet, sheet_index, matching_selectors, all_properties, node_style, is_ancestor, ans)

    if node.getAttribute('style'):
        properties = get_style_properties(node.style, all_properties, node_style, is_ancestor)
        if properties.length > 0:
            data = {'selector':None, 'type':'inline', 'href':get_sourceline_address(node), 'properties':properties, 'rule_address':None, 'sheet_index':None}
            ans.push(data)

    return ans.reverse()

def scroll_to_node(node):
    if node is document.body:
        window.scrollTo(0, 0)
    else:
        node.scrollIntoView()


class PreviewIntegration:

    ###
    # Namespace to expose all the functions used for integration with the Tweak
    # Book Preview Panel.
    ###

    def __init__(self):
        self.blocks_found = False
        self.in_split_mode = False
        if window is window.top:
            setTimeout(self.connect_channel, 10)
        window.document.body.addEventListener('click', self.onclick, True)

    def go_to_line(self, lnum):
        for node in document.querySelectorAll(f'[data-lnum="{lnum}"]'):
            if is_hidden(node):
                continue
            scroll_to_node(node)
            break

    def go_to_sourceline_address(self, sourceline, tags):
        nodes = document.querySelectorAll(f'[data-lnum="{sourceline}"]')
        for index in range(nodes.length):
            node = nodes[index]
            if index >= tags.length or node.tagName.toLowerCase() is not tags[index]:
                break
            if index == tags.length - 1 and not is_hidden(node):
                return scroll_to_node(node)
        self.go_to_line(sourceline)

    def line_numbers(self):
        found_body = False
        ans = v'[]'
        for node in document.getElementsByTagName('*'):
            if not found_body and node.tagName.toLowerCase() is "body":
                found_body = True
            if found_body:
                ans.push(node.dataset.lnum)
        return ans

    def find_blocks(self):
        if self.blocks_found:
            return
        for elem in document.body.getElementsByTagName('*'):
            if is_block(elem) and not in_table(elem):
                elem.setAttribute('data-is-block', '1')
        self.blocks_found = True

    def set_split_mode(self, enabled):
        self.in_split_mode = enabled
        document.body.setAttribute('data-in-split-mode', '1' if enabled else '0')
        if enabled:
            self.find_blocks()

    def report_split(self, node):
        loc = v'[]'
        totals = v'[]'
        parent = find_containing_block(node)
        while parent and parent.tagName.toLowerCase() is not 'body':
            totals.push(parent.parentNode.children.length)
            num = 0
            sibling = parent.previousElementSibling
            while sibling:
                num += 1
                sibling = sibling.previousElementSibling
            loc.push(num)
            parent = parent.parentNode
        loc.reverse()
        totals.reverse()
        self.bridge.request_split(JSON.stringify(loc), JSON.stringify(totals))

    def connect_channel(self):
        self.qwebchannel = new window.QWebChannel(window.qt.webChannelTransport, def(channel):
            self.bridge = channel.objects.bridge
            self.bridge.go_to_sourceline_address.connect(self.go_to_sourceline_address)
            self.bridge.go_to_anchor.connect(self.go_to_anchor)
            self.bridge.set_split_mode.connect(self.set_split_mode)
        )

    def onclick(self, event):
        event.preventDefault()
        if self.in_split_mode:
            self.report_split(event.target)
        else:
            e = event.target
            address = get_sourceline_address(e)
            # Find the closest containing link, if any
            href = tn = ''
            while e and e != document.body and e != document and (tn is not 'a' or not href):
                tn = e.tagName?.toLowerCase()
                href = e.getAttribute('href')
                e = e.parentNode
            self.bridge.request_sync(tn, href, JSON.stringify(address))
        return False

    def go_to_anchor(self, anchor):
        elem = document.getElementById(anchor)
        if not elem:
            elem = document.querySelector(f'[name="{anchor}"]')
        if elem:
            elem.scrollIntoView()
            address = get_sourceline_address(elem)
            self.bridge.request_sync('', '', address)

    def live_css(self, sourceline, tags):
        target = None
        i = 0
        for node in document.querySelectorAll(f'[data-lnum="{sourceline}"]'):
            if node.tagName?.toLowerCase() is not tags[i]:
                return JSON.stringify(None)
            i += 1
            target = node
            if i >= tags.length:
                break
        all_properties = {}
        ans = {'nodes':v'[]', 'computed_css':all_properties}
        is_ancestor = False
        while target and target.ownerDocument:
            css = get_matched_css(target, is_ancestor, all_properties)
            # We want to show the Matched CSS rules header even if no rules matched
            if css.length > 0 or not is_ancestor:
                ans.nodes.push({
                    'name':target.tagName?.toLowerCase(),
                    'css':css, 'is_ancestor':is_ancestor,
                    'sourceline':target.getAttribute('data-lnum')
                })
            target = target.parentNode
            is_ancestor = True
        return JSON.stringify(ans)


calibre_preview_integration = PreviewIntegration()
